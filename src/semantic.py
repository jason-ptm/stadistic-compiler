"""
This module implements a semantic analyzer that validates the meaning of a sequence of tokens
generated by the lexer and parser. It ensures that the tokens follow logical rules, such as
positive amounts, valid rates, and correct time values. If any semantic rule is violated,
it raises a custom SemanticError with detailed feedback.

Authors: Jason Stevens Solarte Herrera, Andrés Felipe Vanegas Bogotá
"""

class SemanticAnalyzer:

    def __init__(self, tokens):
        """
        Initializes with a list of tokens.
        """
        self.tokens = tokens  
        self.pos = 0  

    def analyze(self):
        """
        Runs semantic analysis on tokens.
        """
        while self.pos < len(self.tokens):
            self.instruction()

    def instruction(self):
        """
        Identifies and processes the current instruction.
        """
        token_map = {
            'CALCULATE': self.calculate_instruction,
            'DEFINE': self.define_rate,
            'PAYMENT': self.payment,
            'BALANCE': self.balance,
            'SAVINGS': self.savings,
            'INVESTMENT': self.investment,
            'ANNUITY': self.annuity
        }
        action = token_map.get(self.tokens[self.pos][0])
        if action:
            action()
        else:
            self.error('Unexpected token')

    def calculate_instruction(self):
        """
        Validates 'CALCULATE' instructions.
        """
        self.match('CALCULATE')
        options = {'INTEREST': self.calculate_interest, 'MATURITY': self.calculate_maturity}
        options.get(self.tokens[self.pos][0], lambda: self.error('Expected INTEREST or MATURITY'))()

    def calculate_maturity(self):
        """
        Validates 'MATURITY' calculation.
        """
        self.match('MATURITY')
        self.match('DATE')
        self.match('DATE_VALUE')
        self.match('PERIOD')
        self.match('NUMBER')
        self.match('DAYS')

    def calculate_interest(self):
        """
        Validates 'INTEREST' calculation.
        """
        self.match('INTEREST')
        self.amount()
        self.rate()
        self.time()

    def amount(self):
        """
        Validates amount (must be positive).
        """
        self.match('AMOUNT')
        if self.pos < len(self.tokens):
            if float(self.consume('NUMBER')) <= 0:
                self.error("Amount must be positive")

    def define_rate(self):
        """
        Validates 'DEFINE RATE'.
        """
        self.match('DEFINE')
        self.rate()

    def rate(self):
        """
        Validates rate (0-100 range).
        """
        self.match('RATE')
        if self.pos < len(self.tokens):
            if not (0 <= float(self.consume('NUMBER')) <= 100):
                self.error("Rate must be between 0 and 100")

    def payment(self):
        """Validates 'PAYMENT' instruction."""
        self.match('PAYMENT')
        self.match('NUMBER')

    def balance(self):
        """Validates 'BALANCE' instruction."""
        self.match('BALANCE')

    def savings(self):
        """Validates 'SAVINGS' instruction."""
        self.match('SAVINGS')

    def investment(self):
        """Validates 'INVESTMENT' instruction."""
        self.match('INVESTMENT')

    def annuity(self):
        """Validates 'ANNUITY' instruction."""
        self.match('ANNUITY')

    def time(self):
        """
        Validates time (must be positive, followed by 'YEARS').
        """
        self.match('TIME')
        if self.pos < len(self.tokens):
            if float(self.consume('NUMBER')) <= 0:
                self.error("Time must be positive")
            self.match('YEARS')

    def match(self, expected_type):
        """
        Checks and advances if token matches expected type.
        """
        if self.pos < len(self.tokens) and self.tokens[self.pos][0] == expected_type:
            self.pos += 1
        else:
            self.error(f"Expected {expected_type}")

    def consume(self, expected_type):
        """
        Matches token and returns its value.
        """
        if self.pos < len(self.tokens) and self.tokens[self.pos][0] == expected_type:
            value = self.tokens[self.pos][1]
            self.pos += 1
            return value
        else:
            self.error(f"Expected {expected_type}")

    def error(self, message):
        """
        Raises a semantic error.
        """
        raise SemanticError(f"Semantic error at token {self.pos}: {message}")

class SemanticError(Exception):
    """Custom exception for semantic errors."""
    pass
